//#define Trace
//
// AppUpdater.cs
//
// ------------------------------------------------------------------
//
// This file defines the main class for an application updater, for use
// with WPF, as well as a few related support classes.
//
// All well-behaved applications need a way to get updated.  Complex applications
// get installed with MSI installers, and can be updated via that mechanism too.
//
// Simpler applications, for example, those that are not formally installed, those
// that are distributed as a single (.exe) assembly, need a simpler way of being
// updated.
//
// This updater class provides a simple mechanism for simple applications to be
// updated.
//
// For more on the idea,
// http://blogs.msdn.com/dotnetinterop/archive/2008/03/28/simple-auto-update-for-wpf-apps.aspx
//
//
// Created Sun, 09 Aug 2009  12:42
//
// last saved: 
// Time-stamp: <2009-August-09 12:42:35>
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2009 by Dino Chiesa
// All rights reserved.
//
// ------------------------------------------------------------------

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;
using System.Diagnostics;                   // Process, ConditionalAttribute
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;  // Hyperlink


namespace TerrariViewer.AppUpdater.Wpf
{
    /// <summary>
    /// This is a Simple Application Updater that can be used with WPF apps.
    /// </summary>
    /// <remarks>
    /// <para>
    /// There are fancy things to do with AppDomains and so on.  There's also 
    /// the App Updater Block, which is sophisticated and can handle apps of many 
    /// parts, with many downloadable modules. The approach used here is simple,
    /// much simpler than these other approaches. 
    /// </para>
    ///
    /// <para>
    /// The main challenge with updating an EXE app is that the EXE image in the
    /// filesystem is write-locked while the EXE is executing within a process.
    /// </para>
    ///
    /// <para>
    /// This updater works by explicity copying the running EXE image to a
    /// temporary directory, and starting that copy of the EXE. The original
    /// process stops, which unlocks the original EXE image, and allows it to be
    /// overwritten.  The "updater clone" EXE then downloads the new EXE from a
    /// given location, and starts a new process with that EXE.  The updater clone
    /// then stops itself.  The end.
    /// </para>
    ///
    /// <para>
    /// To protect against malicious update interception, this approach computes
    /// the MD5 hash for the downloaded image, and checks that hash against the
    /// hash listed in the update manifest.  The update goes forward only if the
    /// hashes match.
    /// </para>
    ///
    /// <para>
    /// There is a limitation that copying over the EXE image may be disallowed if
    /// people don't run the application with the appropriate permissions.
    /// </para>
    ///
    /// <para>
    /// But, assuming all those things work out, this class is a quick and dirty
    /// way to automatically update "no install" WPF or WinForms applications.
    /// </para>
    /// </remarks>
    public class Updater
    {
        private Object _lock = new Object();
        private bool cancelAction;
        private string _manifestUrl;
        private System.Reflection.Assembly _a;
        private String _infoUrl;
        private String _intro;
        private String _description;
        private UpdateStatus _status;
        private Nullable<bool> _wantUpdate;
        private System.Exception _LastException;
        private string _manifestXml;
        private UpdateInfo _info;
        private string _mutexId;
        private System.Diagnostics.Process _process;
        private string _tempLocation;
        private TextBlock tb1, tb2, tb3;

        Window window;
        Button button1 = null;
        Button button2 = null;
        ProgressBar pbDownload = null;

        // Indexed command line args using hash table
        private System.Collections.Generic.Dictionary<String, String> CommandLineArgs;


        /// <summary>
        /// This creates an Updater instance.
        /// </summary>
        private Updater() { }


        /// <summary>
        /// Creates an AppUpdater. 
        /// The URL for the update manifest is specified.
        /// </summary>
        ///
        /// <param name="manifestUrl">
        ///   Specifies the URL for the app update manifest.  This is typically
        ///   something like http://server/AppUpdates/AppName/Manifest.xml .  The
        ///   contents of this file is generated by the CreateAppUpdateManifest.exe
        ///   tool.  Only HTTP sites are supported, and only using the default WebProxy
        ///   and credentials.
        /// </param>
        ///
        /// <param name="infoUrl">
        ///   The URL for the application, if any.
        /// </param>
        ///
        /// <param name="intro">
        ///   A 10-word introductory description for the application.  For example,
        ///   "This is SuperApp.  It organizes your photos."
        /// </param>
        ///
        /// <param name="description">
        ///   A 25-100 word, more detailed description for the application. It may
        ///   describe how it works, when it was built, how it is licensed, and many
        ///   other things.
        /// </param>
        ///
        public Updater(string intro,
                       string infoUrl,
                       string description,
                       string manifestUrl)
        {
            SetupDebugConsole();   // For Debugging only

            Trace("hello");

            _manifestUrl = manifestUrl;
            _infoUrl = infoUrl;
            _intro = intro;
            _description = description;

            BuildArgDictionary();

            // acquire a mutex specific to this exe image
            byte[] hash = ComputeHash(_CurrentExeName);
            _mutexId = ByteArrayToString(hash);
            System.Threading.Mutex _mutex = new System.Threading.Mutex(false, _mutexId);

            Trace("my mutexId:        {0}", _mutexId);

            // create the mutex, and acquire it.
            while (!_mutex.WaitOne(60, false)) ;

            Trace("got startup mutex: {0}", _mutexId);

            // The mutex will be released when the process exits. 
            // The app uses this mutex to signal when a process exits, so that
            // the exe can be deleted or overwritten.

            if (IsInUpdaterApp())
            {
                Trace("in updater app", _mutexId);

                Phase2_DownloadUpdate_StartIt_And_Die();
            }
            else
            {
                Trace("maybe cleanup", _mutexId);

                Phase3_MaybeCleanUp();

                Trace("checking for update", _mutexId);

                // start the check thread
                var worker = new System.ComponentModel.BackgroundWorker();
                worker.DoWork += CheckLatest;
                worker.RunWorkerCompleted += CheckCompleted;
                worker.RunWorkerAsync();
            }
        }



        // BackgroundWorker DoWork method
        private void CheckLatest(object sender, System.ComponentModel.DoWorkEventArgs e)
        {
            IsUpdateAvailable();
        }



        // BackgroundWorker RunWorkerCompleted method
        // fired when worker has completed its work
        private void CheckCompleted(object sender, System.ComponentModel.RunWorkerCompletedEventArgs e)
        {
            if (e.Cancelled)
            {
            }
            else if (e.Error != null)
            {
            }
            else
            {
                // display the dialog box if there is an update available.
                if (HaveCheckedForUpdate && IsUpdateAvailable())
                {
                    _status = new UpdateStatus() { Success = true, Message = "Update is available." };
                    PopUpdateWindow();
                }
            }
        }



        #region Public Properties

        /// <summary>
        /// Returns the most recent exception that occurred.
        /// </summary>
        ///
        public System.Exception LastException
        {
            get { return _LastException; }
        }


        /// <summary>
        /// Returns the version of the currently executing assembly.
        /// </summary>
        ///
        /// <remarks>
        /// Just a shorthand for calling System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString();
        /// </remarks>
        ///
        public string AppCurrentVersion
        {
            get
            {
                return _MyAssembly.GetName().Version.ToString();
            }
        }

        public bool HaveCheckedForUpdate
        {
            get
            {
                return _wantUpdate.HasValue;
            }
        }

        public UpdateStatus Status
        {
            get
            {
                return _status;
            }
        }


        public string AppLatestVersion
        {
            get
            {
                if (_info == null)
                {
                    GetUpdateInfo();
                }
                return _info.LatestAvailableVersion;
            }
        }

        public DateTime AppLatestPublishTimestamp
        {
            get
            {
                if (_info == null)
                {
                    GetUpdateInfo();
                }
                return _info.TimeStamp;
            }
        }


        public bool UpdateIsAvailableAndValid
        {
            get
            {
                if (_info == null)
                {
                    GetUpdateInfo();
                }
                return _info.UpdateIsAvailableAndValid;
            }
        }

        #endregion


        #region public methods


        public void ShowStatus()
        {
            if (_status == null)
                GetUpdateInfo();

            PopUpdateWindow();
        }

        public bool IsUpdateAvailable()
        {
            lock (_lock)
            {
                if (_wantUpdate.HasValue) return _wantUpdate.Value;

                string CurrentVersion = AppCurrentVersion;
                var CurrentVersionInts = CurrentVersion.Split(".".ToCharArray()).ToList<String>().
                    ConvertAll(s => Convert.ToInt32(s));

                GetUpdateInfo();

                var LatestVersionInts = AppLatestVersion.Split(".".ToCharArray()).ToList<String>().
                    ConvertAll(s => Convert.ToInt32(s));

                bool wantUpdate = false;
                for (int i = 0; i < CurrentVersionInts.Count; i++)
                {
                    if (i < LatestVersionInts.Count)
                    {
                        if (CurrentVersionInts[i] < LatestVersionInts[i])
                            wantUpdate = true;
                        else if (CurrentVersionInts[i] > LatestVersionInts[i])
                            break;
                    }
                    if (wantUpdate) break;
                }
                _wantUpdate = new Nullable<bool>(wantUpdate);
            }

            return _wantUpdate.Value;
        }

        #endregion


        #region private methods

        private void Phase2_DownloadUpdate_StartIt_And_Die()
        {
            if ((CommandLineArgs == null) || (!CommandLineArgs.ContainsKey("orig")))
            {
                _status = new UpdateStatus() { Success = true, Message = "not updating." };
            }

            string targetExe = CommandLineArgs["orig"];
            Trace("download to orig exe: {0}", targetExe);
            string tmpExe = targetExe + "." + Path.GetRandomFileName();

            GetUpdateInfo();
            _status = new UpdateStatus() { Success = false, IsUpdating = true, Message = "unknown" };

            try
            {
                StartDownloadImage(_AppLatestImageUrl, tmpExe);
            }
            catch (Exception ex1)
            {
                _status.Success = false;
                _status.Message = String.Format("During update...\nThe download failed with {0}", ex1);
                _LastException = ex1;
            }

        }


        /// <summary>
        /// Downloads the image from the specified url to the specified local file name.
        /// </summary>
        private void StartDownloadImage(String url, String localFileName)
        {
            CreateWindow();
            Application.Current.MainWindow = window;

            Trace("Download to {0}", localFileName);

            pbDownload = LogicalTreeHelper.FindLogicalNode(window, "pbDownload") as ProgressBar;
            int imageSize = GetContentLength(url);
            pbDownload.Maximum = imageSize;
            pbDownload.Visibility = Visibility.Visible;

            tb1.Text = String.Format("You are running version {0} of this application.\r\n" +
                                     "An update to version {1} of this application is available.",
                                     AppCurrentVersion, AppLatestVersion);

            tb2.Text = "Downloading the update...";

            // display a "wait" cursor
            System.Windows.Input.Mouse.OverrideCursor = System.Windows.Input.Cursors.Wait;

            Object[] args = { url, localFileName, imageSize };

            var downloader = new System.ComponentModel.BackgroundWorker();
            downloader.DoWork += DownloadWorker;
            downloader.RunWorkerCompleted += DownloadCompleted;
            downloader.RunWorkerAsync(args);

            button1.Visibility = Visibility.Collapsed;
            button2.Content = "Cancel";

            window.Show();
        }



        // need the length for the progress bar
        private int GetContentLength(string url)
        {
            System.Net.WebHeaderCollection headers = null;
            System.Net.HttpWebResponse response = null;
            try
            {
                System.Net.HttpWebRequest request = System.Net.WebRequest.Create(url) as System.Net.HttpWebRequest;
                MarkNoCache(request);
                request.Method = "HEAD";
                response = request.GetResponse() as System.Net.HttpWebResponse;
                headers = response.Headers;
            }
            finally
            {
                //  avoid leaking connections
                if (response != null)
                    response.Close();
            }

            if (headers.Get("Content-Length") != null)
                return System.Int32.Parse(headers.Get("Content-Length"));

            return -1;
        }



        // BackgroundWorker DoWork method
        private void DownloadWorker(object sender, System.ComponentModel.DoWorkEventArgs e)
        {
            Object[] args = (Object[])e.Argument;
            string url = (String)args[0];
            string imageName = (String)args[1];
            int imageSize = (int)args[2];
            if (!DownloadWorker2(url, imageName, imageSize))
                e.Cancel = true;
            else
                e.Result = imageName;
        }



        private bool DownloadWorker2(string url, string imageName, int imageSize)
        {
            byte[] buf = new byte[2048];
            int n = 0;
            _LastException = null;

            System.Net.WebRequest req = System.Net.WebRequest.Create(url);
            MarkNoCache(req);

            System.Net.WebResponse resp = req.GetResponse();
            int totalBytesTransferred = 0;
            //var action = new Action<ProgressBar, int>((p, v) => {p.Value = v; HideOtherWindows();});
            var action = new Action<ProgressBar, int>((p, v) => p.Value = v);
            cancelAction = false;
            using (Stream s1 = new FileStream(imageName, FileMode.CreateNew))
            {
                using (Stream s2 = resp.GetResponseStream())
                {
                    do
                    {
                        n = s2.Read(buf, 0, buf.Length);
                        // delay, so that the progress bar is visible even for relatively
                        // small downloads.
                        if (imageSize < 20000)
                            System.Threading.Thread.Sleep(250);
                        else if (imageSize < 40000)
                            System.Threading.Thread.Sleep(100);
                        else if (imageSize < 100000)
                            System.Threading.Thread.Sleep(50);
                        else if (imageSize < 250000)
                            System.Threading.Thread.Sleep(20);
                        totalBytesTransferred += n;
                        if (n > 0)
                            s1.Write(buf, 0, n);
                        pbDownload.Dispatcher.Invoke(action, pbDownload, totalBytesTransferred);
                    } while (n > 0 && !cancelAction);
                }
            }

            return !cancelAction;
        }


        // BackgroundWorker RunWorkerCompleted method
        // fired when worker has completed its work
        private void DownloadCompleted(object sender, System.ComponentModel.RunWorkerCompletedEventArgs e)
        {
            button2.Content = "Close";

            if (e.Cancelled)
            {
                tb3.Text = "The download was cancelled.";
                tb3.Visibility = Visibility.Visible;
            }
            else if (e.Error != null)
            {
            }
            else
            {
                tb2.Text = "The download is complete...";
                string targetExe = CommandLineArgs["orig"];
                string tmpExe = (string)e.Result;
                tb3.Text = "verifying...";
                tb3.Visibility = Visibility.Visible;

                // verify that the downloaded image matches the Manifest, via the signed
                // hash, and the other metadata.
                if (VerifyAssembly(tmpExe))
                {
                    tb3.Text = "verification is complete...";

                    // This is only for sanity check - the original exe
                    // is likely to be closed already.
                    WaitForExit(targetExe);

                    // Copy the downloaded image to the destination file (with overwrite):
                    File.Copy(tmpExe, targetExe, true);
                    File.Delete(tmpExe);

                    tb3.Text = "Starting the updated version, please wait...";

                    var worker = new System.ComponentModel.BackgroundWorker();
                    worker.DoWork += WaitForNewProcess;
                    worker.RunWorkerCompleted += WaitForNewProcessCompleted;
                    worker.RunWorkerAsync(targetExe);

                    // The updater starts the EXE, using the original name and location.
                    string arg = "\"/rmfile:" + _CurrentExeName + "\"";
                    Trace("Starting {0} {1}", targetExe, arg);
                    System.Diagnostics.Process.Start(targetExe, arg);

                }
                else
                {
                    tb3.Text = "During verify...\r\n" +
                               "The hash for the downloaded image did not match the manifest. Verification has failed.";
                    tb3.Foreground = System.Windows.Media.Brushes.Red;
                }
            }
        }



        private void UpdateTb3(string text)
        {
            if (tb3.CheckAccess())
            {
                // The calling thread owns the dispatcher, and hence the UI element
                tb3.Text = text;
            }
            else
            {
                tb3.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal,
                                      new Action<string>(UpdateTb3), text);
            }
        }


        private void WaitForNewProcess(object sender, System.ComponentModel.DoWorkEventArgs e)
        {
            String image = (string)e.Argument;
            byte[] hash = ComputeHash(image);
            string id = ByteArrayToString(hash);
            int sleepInterval = 2150;  // for the initial sleep

            cancelAction = false;

            // create a new mutex and acquire it
            var mutex = new System.Threading.Mutex(false, id);  // _mutexId

            Trace("await proc start:  {0}", id);

            // acquire, release, and sleep in a loop until we cannot acquire it again...
            while (mutex.WaitOne(20, false) && !cancelAction)
            {
                mutex.ReleaseMutex();
                System.Threading.Thread.Sleep(sleepInterval);
                if (sleepInterval != 400) sleepInterval = 400;  // subsequent cycles
            }

            Trace("the new process is started");

            // Need to do this on the UI thread.
            UpdateTb3("The new process is starting up...");

            // This means the updated process has started and acquired the mutex.
            // *This* process can now exit, which it does in the WaitForNewProcessCompleted method.
            // When this process exits, the other one will remove the old, temporary (clone) EXE.

            Trace("exiting");
            //System.Threading.Thread.Sleep(2150); // allow user to read?
        }




        private void WaitForNewProcessCompleted(object sender, System.ComponentModel.RunWorkerCompletedEventArgs e)
        {
            // The new process has started, time for this one to exit. 
            System.Windows.Application.Current.Shutdown();
        }


        private void WaitForExit(string imageName)
        {
            byte[] hash = ComputeHash(imageName);
            string id = ByteArrayToString(hash);
            var mutex = new System.Threading.Mutex(false, id);
            while (!mutex.WaitOne(250, false)) ;
            return;
        }

        private void Phase3_MaybeCleanUp()
        {
            _status = new UpdateStatus() { Success = true, Message = "No cleanup necessary." };

            // If the process was launched from the updater, then there will be an rmfile argument
            // on the command line.  Try to remove EXE given by that argument. 
            if ((CommandLineArgs != null) && (CommandLineArgs.ContainsKey("rmfile")))
            {
                string fileToRemove = CommandLineArgs["rmfile"];
                _status.Success = true;
                _status.Message = String.Format("Removing file {0}.", fileToRemove);

                // do this asynchronously, for faster startup of the new file. 
                var fileRemover = new System.ComponentModel.BackgroundWorker();
                fileRemover.DoWork += RemoveFile;
                fileRemover.RunWorkerCompleted += RemoveCompleted;
                fileRemover.RunWorkerAsync(fileToRemove);
            }
        }


        private void RemoveCompleted(object sender, System.ComponentModel.RunWorkerCompletedEventArgs e)
        {
            if (e.Error != null)
            {
                _status.Success = false;
                _status.Message = String.Format("Exception while removing file.\nFile: {0}\nException: {1}",
                                                CommandLineArgs["rmfile"],
                                                e.Error.ToString());
            }
            else if ((bool)e.Result)
            {
                _status.Success = true;
                _status.Message = String.Format("Removed file {0}.", CommandLineArgs["rmfile"]);
            }
            else
            {
                _status.Success = true;
                _status.Message = String.Format("Could not remove file {0}.", CommandLineArgs["rmfile"]);
            }
        }




        private void RemoveFile(object sender, System.ComponentModel.DoWorkEventArgs e)
        {
            e.Result = false;
            String fileToRemove = (String)e.Argument;
            //System.Diagnostics.Debugger.Break();
            Exception GotException = null;
            Trace("Removing file {0}", fileToRemove);
            int Tries = 0;
            do
            {
                try
                {
                    Tries++;
                    GotException = null;
                    if (File.Exists(fileToRemove))
                        File.Delete(fileToRemove);

                }
                catch (Exception exc)
                {
                    GotException = exc;
                    // delay before retry
                    System.Threading.Thread.Sleep(120 * (Tries * Tries + Tries));
                }
            } while ((GotException != null) && (Tries < 7));

            e.Result = (GotException == null);
        }


        private bool IsInUpdaterApp()
        {
            String AppName = _MyAssembly.GetName().Name;
            string tempDir = System.Environment.GetEnvironmentVariable("TEMP");
            if (!_CurrentExeName.StartsWith(tempDir)) return false;
            string Pattern = String.Format("{0}-{1}-Update.exe", AppName, "(\\d{4}\\S{3}\\d{2}\\-\\d{6})");
            var m = System.Text.RegularExpressions.Regex.Match(_CurrentExeName, Pattern);
            if ((m != null) && (m.Captures.Count == 1))
            {
                return true;
            }
            return false;
        }


        private void CreateWindow()
        {
            if (window == null)
            {
                string version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString();

                string s = _XamlTemplate;
                s = s.Replace("@@TITLE", _AppName + " " + version);
                s = s.Replace("@@INFOURL", _infoUrl);
                s = s.Replace("@@INTRO", _intro);
                s = s.Replace("@@DESCRIPTION", _description);

                // Console.WriteLine("{0}", s);
                var reader = new System.Xml.XmlTextReader(new StringReader(s));
                window = System.Windows.Markup.XamlReader.Load(reader) as Window;

                button1 = LogicalTreeHelper.FindLogicalNode(window, "button1") as Button;
                button1.Click += Button1_Click;

                button2 = LogicalTreeHelper.FindLogicalNode(window, "button2") as Button;
                button2.Click += Button2_Click;
                button2.IsEnabled = true;

                SetLinks(window);

                tb1 = LogicalTreeHelper.FindLogicalNode(window, "textBlock1") as TextBlock;
                tb2 = LogicalTreeHelper.FindLogicalNode(window, "textBlock2") as TextBlock;
                tb3 = LogicalTreeHelper.FindLogicalNode(window, "textBlock3") as TextBlock;
            }
        }


        private void PopUpdateWindow()
        {
            CreateWindow();

            if (tb1 == null)
                throw new Exception("Something is very wrong. textBlock1 is null.");

            if (!_status.Success)
            {
                // could check here for LastException . 
                tb1.Text = String.Format("Problem with Application Updater: {0}", _status.Message);
                tb1.Foreground = System.Windows.Media.Brushes.Red;
                button1.Visibility = Visibility.Visible;
                button1.IsEnabled = false;
                button2.Content = "OK";
                // reset, so we check again next time
                _status = null;
            }
            else if (IsUpdateAvailable())
            {
                tb1.Text = String.Format("You are running version {0} of this application.\r\n" +
                                         "An update to version {1} of this application is available.",
                                         AppCurrentVersion, AppLatestVersion);
                button1.Content = "Get Update";
                button1.ToolTip = "Click to download and install the available Update";
                button2.Content = "Not now";
            }
            else
            {
                tb1.Text = String.Format("You are running version {0} of this application.\r\n" +
                                         "No later update is available.",
                                         AppCurrentVersion);
                if (_LastException != null)
                {
                    tb3.Text = String.Format("There was a problem retrieving the update information:\r\n  {0}\r\n" +
                                             "Contact your vendor for support.",
                                             _LastException.Message);
                    tb3.Foreground = System.Windows.Media.Brushes.Red;
                    tb3.Visibility = Visibility.Visible;
                }
                button1.Content = "No Update";
                button1.ToolTip = "No Update is available.  You have the current version.";
                button1.Opacity = 0.3;
                button2.Content = "OK";
            }

            window.ShowDialog();
        }



        private void SetLinks(DependencyObject elt)
        {
            // set the click event for all hyperlinks 
            foreach (var child in LogicalTreeHelper.GetChildren(elt))
            {
                if (child as Hyperlink != null)
                {
                    Hyperlink link = child as Hyperlink;
                    link.Click += Hyperlink_Click;
                }
                else if (child as DependencyObject != null)
                {
                    SetLinks(child as DependencyObject);
                }
            }
        }




        private void BuildArgDictionary()
        {
            string[] args = Environment.GetCommandLineArgs();
            if (args == null) return;
            // Parse command line args for args in the following format:
            //   /argname:argvalue /argname:argvalue /argname:argvalue ...
            //
            // Note: This sample uses regular expressions to parse the command line arguments.
            // For regular expressions, see:
            // http://msdn.microsoft.com/library/en-us/cpgenref/html/cpconRegularExpressionsLanguageElements.asp
            string pattern = @"\/(?<argname>\w+):(?<argvalue>.+)";
            string priorArgname = null;

            CommandLineArgs = new System.Collections.Generic.Dictionary<String, String>();

            for (int i = 1; i < args.Length; i++)
            {
                string arg = args[i];
                System.Text.RegularExpressions.Match match = System.Text.RegularExpressions.Regex.Match(arg, pattern);

                //                 // If match not found, command line args are improperly formed.
                //                 if (!match.Success)
                //                 {
                //                     // handle spaces in the args?
                //                     if (priorArgname != null)
                //                     {
                //                         string v = CommandLineArgs[priorArgname];
                //                         CommandLineArgs.Remove(priorArgname);
                //                         CommandLineArgs.Add(priorArgname, v + " " + arg);
                //                     }
                //                     //throw new ArgumentException("The command line arguments are improperly formed. Use /argname:argvalue.");
                //                 }

                if (match.Success)
                {
                    Trace("Arg: {0}", arg);
                    // Store command line arg and value
                    CommandLineArgs.Add(match.Groups["argname"].Value, match.Groups["argvalue"].Value);
                    priorArgname = match.Groups["argname"].Value;
                }
                else
                {
                    Trace("not Arg?: {0}", arg);
                }
            }
        }


        private void MarkNoCache(System.Net.WebRequest req)
        {
            req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy(System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);
        }


        private string HttpGetString(string url)
        {
            _LastException = null;
            string result = null;
            System.Net.WebRequest req = System.Net.WebRequest.Create(url);
            MarkNoCache(req);
            try
            {
                System.Net.WebResponse resp = req.GetResponse();
                System.IO.StreamReader sr = new System.IO.StreamReader(resp.GetResponseStream());
                result = sr.ReadToEnd().Trim();
            }
            catch (System.Net.WebException exc1)
            {
                _LastException = exc1;
            }
            return result;
        }



        private void GetUpdateInfo()
        {
            _manifestXml = HttpGetString(_manifestUrl);
            if (_manifestXml == null)
            {
                _LastException = new ApplicationException("No Manifest.");
                _info = new UpdateInfo()
                {
                    LatestAvailableVersion = "0.0.0.0",
                    TimeStamp = System.DateTime.Now,
                    UpdateIsAvailableAndValid = false
                };
                return;
            }

            // Create a new XML document.
            XmlDocument xmlDoc = new XmlDocument();

            // Load an XML file into the XmlDocument object.
            xmlDoc.PreserveWhitespace = true;
            xmlDoc.LoadXml(_manifestXml);


            XmlSerializer s = new XmlSerializer(typeof(UpdateInfo));
            using (var sr = new StringReader(_manifestXml))
            {
                _info = (UpdateInfo)s.Deserialize(new System.Xml.XmlTextReader(sr));
                _info.UpdateIsAvailableAndValid = true;
            }
            return;
        }


        private static string ByteArrayToString(byte[] buffer)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            foreach (byte b in buffer)
                sb.Append(b.ToString("X2"));

            return (sb.ToString());
        }


        private bool VerifyAssembly(string imageName)
        {
            bool result = false;
            try
            {
                // read the file into memory, and load the assembly from THAT.
                // reason: Cannot unload assembly and thus cannot delete the file, if
                // the assembly has been loaded from a file.
                byte[] chunk = File.ReadAllBytes(imageName);
                var a = System.Reflection.Assembly.Load(chunk);

                if (_info.AssemblyFullName != a.GetName().FullName)
                    throw new ApplicationException("Assembly name does not match.");

                if (_info.LatestAvailableVersion != ExtractVersion(a.GetName().FullName))
                    throw new ApplicationException("Assembly version mismatch.");

                result = true;
            }
            catch (Exception ex1)
            {
                _LastException = ex1;
            }

            return true;
        }

        private static string ExtractVersion(string AssemblyFullName)
        {
            string pattern = @".+, Version=(?<version>\d+\.\d+\.\d+\.\d+), .+";
            System.Text.RegularExpressions.Match m = System.Text.RegularExpressions.Regex.Match(AssemblyFullName, pattern);

            if (m.Success)
            {
                if ((m != null) && (m.Captures.Count == 1))
                {
                    return m.Groups["version"].ToString();
                }
            }
            return "0.0.0.0";
        }


        private static HashAlgorithm GetHashAlgorithm()
        {
            return new SHA256CryptoServiceProvider();
        }


        public static byte[] ComputeHash(string Image)
        {
            byte[] hash = null;
            HashAlgorithm alg = GetHashAlgorithm();
            using (FileStream fs = new FileStream(Image, FileMode.Open, FileAccess.Read))
            {
                hash = alg.ComputeHash(fs);
            }

            return hash;
        }


        #endregion



        #region private properties

        private System.Reflection.Assembly _MyAssembly
        {
            get
            {
                if (_a == null)
                {
                    _a = System.Reflection.Assembly.GetExecutingAssembly();
                }
                return _a;
            }
        }


        private string _CurrentExeName
        {
            get
            {
                String AppExe = _MyAssembly.Location;
                return AppExe;
            }
        }


        private string _AppName
        {
            get { return _MyAssembly.GetName().Name; }
        }


        private string _AppLatestImageUrl
        {
            get
            {
                if (_info == null)
                {
                    GetUpdateInfo();
                }
                return _info.DownloadLocation;
            }
        }


        private string _TempFileNameLocation
        {
            get
            {
                if (_tempLocation == null)
                {
                    String AppName = _MyAssembly.GetName().Name;
                    string tempDir = System.Environment.GetEnvironmentVariable("TEMP");
                    if (tempDir == null) return null;
                    do
                    {
                        if (_tempLocation != null) System.Threading.Thread.Sleep(200);
                        string UpdateImageName = String.Format("{0}-{1}-Update.exe", AppName, System.DateTime.Now.ToString("yyyyMMMdd-HHmmss"));
                        _tempLocation = System.IO.Path.Combine(tempDir, UpdateImageName);
                    } while (System.IO.File.Exists(_tempLocation));
                }
                return _tempLocation;
            }
        }

        #endregion


        #region UI Control Event handlers

        private void Hyperlink_Click(object sender, RoutedEventArgs e)
        {
            // open URL
            Hyperlink source = sender as Hyperlink;
            if (source != null)
            {
                System.Diagnostics.Process.Start(source.NavigateUri.ToString());
            }
        }


        private void Button1_Click(object sender, RoutedEventArgs e)
        {
            if ((string)button1.Content == "Get Update")
            {
                if (IsUpdateAvailable())
                {
                    System.Diagnostics.Process.Start("https://terrariviewer.codeplex.com/releases/view/113343#DownloadId=742775");
                    button1.Visibility = Visibility.Collapsed;
                    button2.Content = "Close";
                }
            }
        }


        private void Button2_Click(object sender, RoutedEventArgs e)
        {
            string content = (string)button2.Content;
            if (content == "Close" || content == "OK" || content == "Not now")
            {
                cancelAction = true;
                window.Close();
                window = null; // reset
            }
            else if (content == "Cancel")
            {
                cancelAction = true;
            }
        }


        #endregion

        /// <summary>
        /// Start the update process, which occurs in several steps across
        /// multiple OS processes.
        /// </summary>
        ///
        /// <remarks>
        /// <para>
        /// There are two steps involved for an application that automatically
        /// updates itself.  First is to determine the latest available version of
        /// the app image.  Second is to get the latest version and replace the
        /// old version with the new version.
        /// </para>
        ///
        /// <para>
        /// The solution to the first problem is simple: just an HTTP GET (in the
        /// REST tradition) on a text file or XML file containing the version
        /// number. 
        /// </para>
        ///
        /// <para>
        /// The second problem is more challenging. The application can download
        /// (HTTP GET) the updated version of the app image, with an HTTP GET just
        /// as was used to get the version number.  For a reasonably sized app
        /// (let's say up to 1mb EXE image size), this will be reasonably fast,
        /// well within the realm of acceptable performance. But, while the
        /// original EXE is running, the EXE image on disk is locked.  It cannot
        /// be overwritten.
        /// </para>
        ///
        /// <para>
        /// In order to facilitate the self-update, the executing application must
        /// not be running.  Therefore it must replicate itself, to get out of its
        /// own way.  It works like this: the Application starts up. Call this
        /// process #1.  It checks for available updates.  If it finds an update,
        /// it replicates - copies its own outdated EXE image to another location,
        /// a temporary location.  Process #1 then does a Process.Start() on the
        /// copy of the EXE image.  The result process is process #2.  Process #1
        /// then exits, "getting out of its own way", so that the original EXE
        /// image on disk can be overwritten.  Process #2 then downloads the
        /// latest, updated EXE image, and copies it to the original location - a
        /// location it received through command line arguments passed by Process
        /// #1. Process #2 then does a Process.Start() on the original EXE
        /// location, which now holds an updated exe image; this creates process
        /// #3.  Process #2 then exits.  Process #3, checks for updates and finds
        /// none, since it is the running from the latest EXE image.  Process #3
        /// can also clean up the temporary image used for Process #2. This is
        /// just good manners and not strictly necessary for correctness.
        /// </para>
        ///
        /// <para>
        /// This method takes care of the second problem.  It should be called only after
        /// <see cref="IsUpdateAvailable()"/> returns true. 
        /// </para>
        /// </remarks>
        ///
        /// <example>
        /// <code lang="C#">
        ///
        /// private void Button_Click(object sender, RoutedEventArgs e)
        /// {
        ///     if (Updater.IsUpdateAvailable())
        ///     {
        ///         Updater.KickoffUpdate();
        ///     }
        /// }
        ///
        /// </code>
        /// </example>
        public void KickoffUpdate()
        {
            Trace("KickoffUpdate");
            // copy current EXE to an alternative exe name, then start it up.
            if (_TempFileNameLocation != null)
            {
                System.IO.File.Copy(_CurrentExeName, _TempFileNameLocation);
                if (System.IO.File.Exists(_TempFileNameLocation))
                {
                    // start the updater app
                    string arg = "\"/orig:" + _CurrentExeName + "\"";
                    Trace("Starting {0} {1}", _TempFileNameLocation, arg);

                    System.Diagnostics.Process.Start(_TempFileNameLocation, arg);

                    // then, suicide
                    try
                    {
                        //this._Window.Close();
                        System.Windows.Application.Current.Shutdown();
                    }
                    catch (Exception e1)
                    {
                        Console.WriteLine("Whoops!" + e1.ToString());
                    }
                }
            }
        }

        private string _XamlTemplate = @"
        <Window
              xmlns   = 'http://schemas.microsoft.com/netfx/2007/xaml/presentation'
              xmlns:x = 'http://schemas.microsoft.com/winfx/2006/xaml'
              Title   = '@@TITLE' 
              Height  = '275'
              Width   = '380'>

            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height='*'/>
                    <RowDefinition Height='Auto'/>
                </Grid.RowDefinitions>

                    <StackPanel Grid.Row='0' Margin='8,8,8,8'>
                        <StackPanel.Resources>
                            <Style TargetType='TextBlock'>
                                <Setter Property='TextWrapping' Value='Wrap'/>
                                <Setter Property='Margin' Value='0,2,0,10'/>
                            </Style>
                        </StackPanel.Resources>

                        <TextBlock>@@INTRO</TextBlock>
                        <TextBlock>
                            <Hyperlink NavigateUri='@@INFOURL'>@@INFOURL</Hyperlink>
                        </TextBlock>
                        <TextBlock Name='textBlock1'/>
                        <TextBlock Name='textBlock2'></TextBlock>
                        <TextBlock Name='textBlock3' FontWeight='Bold'   Visibility='Collapsed'/>
                        <ProgressBar Name='pbDownload'
                                     Margin='4,10,4,10' 
                                     HorizontalAlignment='Center'
                                     Width='320' Height='20'
                                     Visibility='Collapsed'/>
                     </StackPanel>

                    <WrapPanel HorizontalAlignment='Right' Grid.Row='1' Grid.ColumnSpan='2'>
                        <Button Name='button1' Margin='4' Height='23' Padding='10,0,10,0'>Check For Updates</Button>
                        <Button Name='button2' Margin='4' Height='23' Padding='14,0,14,0'>Close</Button>
                    </WrapPanel>
                </Grid>
        </Window>";



        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        private static extern bool AllocConsole();

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        private static extern bool AttachConsole(int pid);


        [Conditional("Trace")]
        private void SetupDebugConsole()
        {
            if (!AttachConsole(-1))  // Attach to a parent process console
                AllocConsole(); // Alloc a new console

            _process = System.Diagnostics.Process.GetCurrentProcess();
            System.Console.WriteLine();
        }


        [Conditional("Trace")]
        private void Trace(string format, params object[] args)
        {
            System.Console.Write("{0:D5} ", _process.Id);
            System.Console.WriteLine(format, args);
        }


    }
}



namespace TerrariViewer.AppUpdater
{
    [XmlRoot(Namespace = "urn:TerrariViewer.Apps.Updates")]
    public class UpdateInfo
    {
        public UpdateInfo() { TimeStamp = System.DateTime.Now; }

        [XmlElement]
        public string LatestAvailableVersion;

        [XmlElement]
        public String ImageName;

        [XmlElement]
        public String AssemblyFullName;

        [XmlElement]
        public DateTime TimeStamp;

        [XmlElement]
        public string DownloadLocation;

        [XmlIgnore]
        public bool UpdateIsAvailableAndValid;
    }


    public class UpdateStatus
    {
        public bool Success;
        public bool IsUpdating;
        public string Message;
    }

}



